[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "The United States Census Bureau, operating under Titles 13 and 26 of the U.S. Code, are charged with collecting demographic information about people and families living in the US. They are dedicated to providing quality data, which is crucial as they are used for vital tasks such as\n\n\n\n\n\n\nDetermining the distribution of Congressional seats to states;\n\nMaking planning decisions about community services;\nInforming how trillions of dollars in federal funds are distributed to local, state, and tribal governments each year;\nProviding Age Search information (Social Security, Passports, estate resolutions, etc.)\n\n\nSource: https://www.census.gov/about/what.html\n\n\n\n\nThe US Census Bureau has maintained a public Application Programming Interface (API) since 2012 to allow users to send queries to their databases. The API, called the Public Use Microdata Sample (PUMS) API, is accessible by using a specific URL, which need be constructed to contain all the elements of the query. In this instance, the API is the Public Use Microdata Sample (PUMS) API, which utilizes data collected from the American Community Survey (ACS).\nAs stated, the specific variables and terms in the URL used are what define the query and state the terms of the request. The structure of this is:\n\nStructure of PUMS API query URL\n\n\n\n\n\n\n\nElement\nCode Example\nUse\n\n\n\n\nRoot URL\nhttps://api.census.gov/data/2022/acs/acs1/pums?\nRoot address for where the queries should be addressed, and the primary target of the GET() request. This specifically targets\n1) data from 2022,\n2) their ACS data set, and\n3) more specifically the 1-year ACS estimates.\n\n\nQuery parameters\nget=VAR1,VAR2,VAR3\nfor=state:01,02,03\ntabulate=weight(VAR1)\n\nget specifies the specific variables for which we wish to receive data.\nfor specifies the geographic area, where region, division, or state names are represented by numeric codes.\ntabulate is an alternative to get, and would perform aggregation on raw data and return a table of statistics. This parameter is not reviewed or evaluated in this exercise.\n\n\nAdditional Filters\n&VAR=Value\nAny other additional filters that would allow a user to refine the search further and create more specificity.\n\n\n\nOur goal is to write a function that will query this PUMS API for a selection of variables and perform some manipulations and processing of the resulting data sets.\n\n\nWe need to construction a function to query the API [use the GET() function from library(httr)]. A helper function will be needed to take what is returned by get to turn it into a “nice tibble”.\nThis will be a function to query the API that allows the user to specify:\n\nYear of survey (default is 2022; must be a valid value between 2010 and 2022).\nThe numeric variables that could be queried for are:\n\nPWGTP - PUMS person weight, indicating the number of people that a single “person” record could “speak” for. (This variable must be included, and can not be removed by the user.)\nAGEP - Person age (default value along with PWGTP, but this one can be changed)\nGASP - The cost of gas for housing during the 12-month period reviewed.\nGRPIP - Gross Rent as a Percentage of household Income\nJWDP (time) - Time of departure for work.\nJWAP (time) - Time of arrival at work.\nJWMNP - The number of minutes spent commuting to work.\n\nThe categorical variables that could be queried for are:\n\nSEX - This was intended to refer to biological sex of the survey responder, but this survey is self-reporting and voluntary. This is to be the default categorical variable, and multiple can be selected.\nFER - Refers to “fertility”, an indicator variable for whether a woman has given birth within the previous 12 months from the survey. This is only valid for women aged 15 to 50.\nHHL - The household language.\nHISPEED - Indicates if the residence has high-speed internet (fiber optic, DSL, etc.)\nJWTRNS - The primary means of transportation to go to work.\nSCH - School enrollment, this indicates whether a person is currently enrolled in school; and what level they may be in.\nSCHL - The level of degree/schooling a person has received.\n\nThe geographic levels (All, Region, Division, State) should be specified.\nAny numeric, categorical, or geographic levels not specified above will be disregarded.\n\n\n\n\n\n\nThe first step for generation of the function will be to ensure the packages to include, and our constants, are clearly defined. In this case, the constants are the allowable numeric and categorical variables as specified above.\n\nALLOWED_NUMERIC &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\")  # PWGTP always added\nALLOWED_CATEG   &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\nGEO_FIELD       &lt;- c(\"All\"=NA, \"Region\"=\"REGION\", \"Division\"=\"DIVISION\", \"State\"=\"ST\")\nALLOWED_YEARS   &lt;- 2010:2022\n\n\n\n\nSpecific packages will need to be included, to allow us to utilize HTTP protocols to access the API. The data would be transferred as JSON packets, which will need to be translated into a readable format. Finally, the resulting data frames will need to be able to be manipulated and processed for further accessibility.\n\nlibrary(httr)       # For accessing the API with HTTP requests\nlibrary(jsonlite)   # For interpreting data received from API into a readable format.\nlibrary(tidyverse)  # For processing and manipulation of the data.\n\n\n\n\nThe user will be able to define some of the details of the request. These are: year, numeric variables, categorical variables, geographic area, and some filtering variables that would allow further sub-setting. Prior to any request being submitted to the API, the requested input needs to be validated to confirm it fits within required parameters. A helper function check_inputs will review the inputted parameters and stop activity if any items are out of scope.\n\n# Confirm that input request is within allowable parameters\ncheck_inputs &lt;- function(year, numeric_vars, cat_vars, geo, subset) {\n  # Year must be a single integer in our allowed range\n  if (!is.numeric(year) || length(year) != 1 || !(year %in% ALLOWED_YEARS)) {\n    stop(\"Year must be an integer in 2010–2022.\")\n  }\n  # At least one numeric variable (besides the weight PWGTP, which we auto-include)\n  if (length(numeric_vars) &lt; 1) stop(\"provide at least one numeric variable.\")\n  # Only allow variables listed in the spec\n  bad_num &lt;- setdiff(numeric_vars, ALLOWED_NUMERIC)\n  if (length(bad_num)) stop(\"unknown numeric variable(s): \", paste(bad_num, collapse = \", \"))\n  if (length(cat_vars) &lt; 1) stop(\"provide at least one categorical variable.\")\n  bad_cat &lt;- setdiff(cat_vars, ALLOWED_CATEG)\n  if (length(bad_cat)) stop(\"unknown categorical variable(s): \", paste(bad_cat, collapse = \", \"))\n  # Geography must be one of these levels\n  if (!(geo %in% names(GEO_FIELD))) {\n    stop(\"geo must be one of: \", paste(names(GEO_FIELD), collapse = \", \"))\n  }\n  # If a subset is given, it must match the chosen geography and be coded as API codes\n  if (!is.null(subset)) {\n    if (geo == \"All\") stop(\"subset cannot be used when geo = 'All'.\")\n    if (!is.character(subset) || any(!nzchar(subset))) {\n      stop(\"subset must be a character vector of codes for the chosen geography.\")\n    }\n  }\n  invisible(TRUE)\n}\n\n\n\n\nAs stated, the specifics for a query submitted to the API are done through so through the contents of the URL. The next functions generate the URL according to the search terms provided.\n\n# Form the base of the URL according to the year of the database to be used (defaults to 2022)\npums_base &lt;- function(year=2022) sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums\", year)\n\n# Building the Census API URL\nbuild_url &lt;- function(year, get_vars, geo, subset_codes) {\n  base &lt;- pums_base(year)\n  geo_field &lt;- GEO_FIELD[[geo]]\n  \n  # Always include PWGTP (weight). Include geo field so it appears in results.\n  get_list &lt;- unique(c(get_vars, \"PWGTP\", if (!is.na(geo_field)) geo_field))\n  \n  # Encode only the list of columns after get=\n  url &lt;- paste0(base, \"?get=\", URLencode(paste(get_list, collapse = \",\")))\n  \n  # If user asked for a subset (e.g., specific states), add \"&ST=37,45\"\n  if (!is.na(geo_field) && length(subset_codes)) {\n    url &lt;- paste0(url, \"&\", geo_field, \"=\", paste(subset_codes, collapse = \",\"))\n  }\n  url\n}\n\n\n\n\nAssuming the variable inputs are appropriately within scope, the request would submitted to the API. The metadata that is returned would be coded (even after translating from JSON). Some helper functions are needed to translate these labels into human-readable variable names.\n\n# Get the variable dictionary (metadata) for a given year.\n# Returns a big list, or NULL if the request fails.\nget_variables_metadata &lt;- function(year) {\n  # Build the variables.json URL for the chosen year\n  url  &lt;- paste0(pums_base(year), \"/variables.json\")\n  # Make a GET request\n  resp &lt;- httr::GET(url)\n  # If HTTP error (e.g., 404/500), just return NULL quietly\n  if (httr::http_error(resp)) return(NULL)\n  # Pull the response text and convert from JSON to an R list\n  txt &lt;- httr::content(resp, as = \"text\", encoding = \"UTF-8\")\n  meta &lt;- jsonlite::fromJSON(txt, simplifyVector = FALSE)\n  return(meta)\n}\n\n# From the metadata list, build a simple lookup (named character vector)\n# for a variable: names = codes, values = human-readable labels.\n# If the variable has no labels, return NULL.\n# label_lookup(): always return named {code -&gt; label} \nlabel_lookup &lt;- function(meta, var) {\n  if (is.null(meta) || is.null(meta$variables)) return(NULL)\n  entry &lt;- meta$variables[[var]]\n  if (is.null(entry) || is.null(entry$values)) return(NULL)\n  vals &lt;- entry$values\n  # 0) If it's already a nice data.frame with code/label columns\n  if (is.data.frame(vals)) {\n    code_col  &lt;- intersect(c(\"item\",\"value\",\"code\",\"id\"), names(vals))[1]\n    label_col &lt;- intersect(c(\"label\",\"text\",\"description\",\"name\"), names(vals))[1]\n    if (!is.na(code_col) && !is.na(label_col)) {\n      labs &lt;- as.character(vals[[label_col]])\n      names(labs) &lt;- as.character(vals[[code_col]])\n      return(labs)\n  } }\n  # 1) Try to normalize any odd list shape into a data.frame\n  #    by round-tripping through JSON with simplifyVector = TRUE\n  norm &lt;- try(\n    jsonlite::fromJSON(jsonlite::toJSON(vals, auto_unbox = TRUE),\n                       simplifyVector = TRUE),\n    silent = TRUE)\n  if (!inherits(norm, \"try-error\")) {\n    # A) data.frame with columns\n    if (is.data.frame(norm)) {\n      code_col  &lt;- intersect(c(\"item\",\"value\",\"code\",\"id\"), names(norm))[1]\n      label_col &lt;- intersect(c(\"label\",\"text\",\"description\",\"name\"), names(norm))[1]\n      if (!is.na(code_col) && !is.na(label_col)) {\n        labs &lt;- as.character(norm[[label_col]])\n        names(labs) &lt;- as.character(norm[[code_col]])\n        return(labs)\n      } }\n    # B) list with vectors item/label\n    if (is.list(norm) && !is.null(norm$item) && !is.null(norm$label)) {\n      labs &lt;- as.character(norm$label)\n      names(labs) &lt;- as.character(norm$item)\n      return(labs)\n    } }\n  # 2) As a last resort, handle named list/vector directly\n  if (is.list(vals) && !is.null(vals$item) && !is.null(vals$label)) {\n    labs &lt;- as.character(vals$label)\n    names(labs) &lt;- as.character(vals$item)\n    return(labs)\n  }\n  if (!is.null(names(vals))) {\n    labs &lt;- vapply(vals, function(x) {\n      if (is.list(x)) as.character(x[[1]])[1] else as.character(x)[1]\n    }, character(1))\n    names(labs) &lt;- names(vals)\n    return(labs)\n  }\n  # If there is no reliable mapping, then return null.\n  NULL\n}\n\n# Default labels we can fall back to if metadata is awkward\ndefault_labels &lt;- function(var) {\n  if (var == \"SEX\")  return(c(`1`=\"Male\", `2`=\"Female\"))\n  if (var == \"SCHL\") return(c(`16`=\"Regular high school diploma\",\n                              `21`=\"Bachelor's degree\"))\n  NULL\n}\n\n# Is the label map usable for these codes? (must have names, and at least one match)\nvalid_labs &lt;- function(codes_chr, labs_named) {\n  if (is.null(labs_named) || is.null(names(labs_named))) return(FALSE)\n  nm2    &lt;- sub(\"^0+\", \"\", names(labs_named))\n  codes2 &lt;- sub(\"^0+\", \"\", codes_chr)\n  any(codes2 %in% nm2)\n}\n\n# turn raw strings into useful R columns---------------------------------\ncoerce_columns &lt;- function(df, year, numeric_vars, cat_vars, geo) {\n  meta &lt;- get_variables_metadata(year)\n  # 1) plain numeric variables (JWAP/JWDP handled below)\n  plain_numeric &lt;- setdiff(numeric_vars, c(\"JWAP\",\"JWDP\"))\n  for (v in plain_numeric) {\n    if (v %in% names(df)) df[[v]] &lt;- suppressWarnings(as.numeric(df[[v]]))\n  }\n  # 2) time variables -&gt; numeric midpoints (prefer labels; fallback numeric)\n  for (tv in intersect(c(\"JWAP\",\"JWDP\"), numeric_vars)) {\n    if (tv %in% names(df)) {\n      labs_raw &lt;- label_lookup(meta, tv)\n      labs     &lt;- if (valid_labs(df[[tv]], labs_raw)) labs_raw else default_labels(tv)\n      \n      lbl &lt;- map_labels(as.character(df[[tv]]), labs)\n      if (all(is.na(lbl))) {\n        df[[tv]] &lt;- suppressWarnings(as.numeric(df[[tv]]))  # fallback if still no match\n      } else {\n        df[[tv]] &lt;- vapply(lbl, midpoint_from_label, numeric(1))\n      } } }\n  # 3) categorical variables -&gt; factors with readable labels\n  for (cv in cat_vars) {\n    if (cv %in% names(df)) {\n      labs_raw  &lt;- label_lookup(meta, cv)\n      labs      &lt;- if (valid_labs(df[[cv]], labs_raw)) labs_raw else default_labels(cv)\n      lbl       &lt;- map_labels(as.character(df[[cv]]), labs)\n      if (all(is.na(lbl))) {\n        df[[cv]] &lt;- factor(df[[cv]])              # keep codes if we truly can’t map\n      } else {\n        df[[cv]] &lt;- factor(lbl, levels = unique(unname(labs)))\n      } } }\n  # 4) weights numeric\n  if (\"PWGTP\" %in% names(df)) df$PWGTP &lt;- suppressWarnings(as.numeric(df$PWGTP))\n  # 5) label the geography field too (if present)\n  geo_field &lt;- GEO_FIELD[[geo]]\n  if (!is.na(geo_field) && geo_field %in% names(df)) {\n    labs_raw &lt;- label_lookup(meta, geo_field)\n    labs     &lt;- if (valid_labs(df[[geo_field]], labs_raw)) labs_raw else default_labels(geo_field)\n    if (!is.null(labs)) {\n      lbl &lt;- map_labels(as.character(df[[geo_field]]), labs)\n      if (all(is.na(lbl))) {\n        df[[geo_field]] &lt;- factor(df[[geo_field]])\n      } else {\n        df[[geo_field]] &lt;- factor(lbl, levels = unique(unname(labs)))\n      }\n    } else {\n      df[[geo_field]] &lt;- factor(df[[geo_field]])\n    } }\n  df\n}\n\nThe above helper functions are each set up to submit URL requests, receive the data, and process them into readable formats. The following functions pums_get_one_year and pums_get_multi_year process and submit the requests based on whether the query is for one year of data, or for multiple years.\n\n# pulling one year of PUMS--------------------------------- \npums_get_one_year &lt;- function(year, numeric_vars, cat_vars, geo, subset = NULL) {\n  # 1) validate inputs\n  check_inputs(year, numeric_vars, cat_vars, geo, subset)\n  # 2) build URL (PWGTP auto-added in build_url)\n  get_vars &lt;- unique(c(numeric_vars, cat_vars))\n  subset_codes &lt;- if (is.null(subset)) character(0) else subset\n  url &lt;- build_url(year, get_vars, geo, subset_codes)\n  # 3) call the API\n  resp &lt;- httr::GET(url)\n  if (httr::http_error(resp)) {\n    stop(\"API request failed. Status: \", httr::status_code(resp))\n  }\n  # 4) parse JSON (first row = header)\n  txt &lt;- httr::content(resp, as = \"text\", encoding = \"UTF-8\")\n  arr &lt;- jsonlite::fromJSON(txt, simplifyVector = TRUE)\n  if (NROW(arr) &lt; 2) stop(\"API returned no data for these parameters.\")\n  header &lt;- arr[1, ]\n  dat &lt;- tibble::as_tibble(as.data.frame(arr[-1, , drop = FALSE],\n                                         stringsAsFactors = FALSE))\n  names(dat) &lt;- header\n  # 5) coerce + label\n  dat &lt;- coerce_columns(dat, year, numeric_vars, cat_vars, geo)\n  # 6) tag and return\n  as_census(dat)\n}\n\n\n# pulling multiple years (loop + bind rows)------------------------\npums_get_multi_year &lt;- function(years, numeric_vars, cat_vars, geo, subset ) {\n  if (!is.numeric(years) || any(!(years %in% ALLOWED_YEARS))) {\n    stop(\"all years must be in 2010–2022.\")\n  }\n  parts &lt;- vector(\"list\", length(years))\n  for (i in seq_along(years)) {\n    y &lt;- years[i]\n    one &lt;- pums_get_one_year(y, numeric_vars, cat_vars, geo, subset)\n    one$year &lt;- y\n    parts[[i]] &lt;- one\n  }\n  out &lt;- dplyr::bind_rows(parts)\n  as_census(out)\n}\n\n\n\n\n\nA single function can be utilized then that will take the user’s request, and submit it to either of the above functions based on whether the years variable contains a single year or multiple years.\n\n# FUNCTION: pums(years, numeric_vars, cat_vars, geo, subset)\n# Usage: Each variable is a keyword where either a vector (for numeric_vars\n# or cat_vars) or singular variable should be used. \n\n# Default variables:\n# year = 2022\n# numeric_vars: c(\"AGEP\")\n# character_vars: c(\"SEX\")\n# geo: \"All\"\n# subset: null\n\npums &lt;- function(year = 2022,\n                 numeric_vars = c(\"AGEP\"),\n                 cat_vars = c(\"SEX\"),\n                 geo = \"All\",\n                 subset = null) {\n  # Confirm whether `year` is a single numeric value\n  if (length(year) == 1 & is.numeric(year)) {\n    pums_get_one_year(year, numeric_vars, cat_vars, geo, subset)\n  } else if (length(year) &gt; 1 & is.numeric(year)) {\n    pums_get_multi_year(year, numeric_vars, cat_vars, geo, subset)\n  } else stop(\"Unable to process `year` request. Please enter either a single integer for year or a vector of years.\")\n}\n\n\n\n\nA summary function has been created to take our census objects and provide some statistical information.\nThe function was created in a way that took up to three variables:\n\nThe census item generated in the function above;\n(OPTIONAL) A vector or single item with keyword numerics= which will contain the numeric variables selected. An error is generated if the keyword numerics= is used with a categorical column.\n\n\nNote: The PWGTP variable is not returned by default. This must be specifically requested in numerics= in order to call it.\n\n\n(OPTIONAL) A vector or single item with the keyword categoricals= which will contain the categorical variables selected. An error is generated in the keyword categoricals= is used with a numeric column.\n\nThe summary statistics returned will be the mean and standard deviation for each numeric variable, and the counts of each factor for categorical variables. These are returned as named lists, which are convenient for assigning to a variable and calling specific items.\n\nsummary.census &lt;- function(object, ...) {\n  \n  args &lt;- list(...)\n  \n  # Stop if any keywords are included that are not `numerics` or `categoricals`\n  if (length(setdiff(names(args), c(\"numerics\", \"categoricals\")))) {\n    stop(\"Keyword error: keywords must be `numerics=` or `categoricals=` to specify column summary request.\")\n  }\n  \n  # If `numerics` are provided, confirm they are actually numeric variables:\n  if (\"numerics\" %in% names(args)) {\n    if (!all(sapply(object[args$numerics], is.numeric))) {\n      stop(\"Selected numeric variables should all be numeric.\")\n    } else { numerics &lt;- args$numerics }\n  } else {\n    numerics &lt;- names(select(object, where(is.numeric)))\n    # Unless it's specified, do not return PWGTP variable.    \n    numerics &lt;- numerics[!numerics %in% \"PWGTP\"]\n  }\n  \n  # If `categoricals` are provided, confirm they're actually factors:\n  if (\"categoricals\" %in% names(args)) {\n    if (!all(sapply(object[args$categoricals], is.factor))) {\n      stop(\"Selected categorical variables should all be factors.\")\n    } else { categoricals &lt;- args$categoricals }\n  } else categoricals &lt;- names(select(object, where(is.factor)))\n  \n  # Reduce the input `object` to its selected variables.\n  object &lt;- object |&gt; select(numerics, categoricals)\n  \n  # Function to produce `summary` reporting for census object\n  report &lt;- function(obj) {\n    # Numeric variables: return a named list with `mean` and `sigma`\n    if (class(obj) == \"numeric\") list(mean=mean(obj), sigma=sd(obj))\n    # Categorical variables: return unique factors and their counts.\n    else if (class(obj) == \"factor\") table(obj)\n    # Fail if object class is neither numeric nor factor.\n    else stop(\"Improper class passed to report function.\")\n  }\n  lapply(as.list(object), FUN=report)\n}\n\n# THIS IS JUST TO SHOW THAT IT WORKS. Show some examples using the function created here.\nexample &lt;- iris\nclass(example) &lt;- c(\"census\", class(iris))\nsummary(example)\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(numerics)\n\n  # Now:\n  data %&gt;% select(all_of(numerics))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(categoricals)\n\n  # Now:\n  data %&gt;% select(all_of(categoricals))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\n$Sepal.Length\n$Sepal.Length$mean\n[1] 5.843333\n\n$Sepal.Length$sigma\n[1] 0.8280661\n\n\n$Sepal.Width\n$Sepal.Width$mean\n[1] 3.057333\n\n$Sepal.Width$sigma\n[1] 0.4358663\n\n\n$Petal.Length\n$Petal.Length$mean\n[1] 3.758\n\n$Petal.Length$sigma\n[1] 1.765298\n\n\n$Petal.Width\n$Petal.Width$mean\n[1] 1.199333\n\n$Petal.Width$sigma\n[1] 0.7622377\n\n\n$Species\nobj\n    setosa versicolor  virginica \n        50         50         50 \n\n\n\n\n\nSimilar to the summary adaptation above, a plot adaptation is also generated for census objects. This is designed to require a single categorical variable and a single numerical variable, as strings. The usage for this command is\nplot(object, categorical=\"[Categorical Var]\", numerical=\"[Numerical Variable]\")\nwhere [Categorical Var] and [Numerical Var] are substitued with the names of the desired columns of their requisite classes.\n\n# Run plot() on a `census` object.\n\nplot.census &lt;- function(object, categorical, numerical, ...) {\n  args = list(...) # Look at possibly adding options for customization. Add a title, for instance?\n  ggplot(object,\n         aes(x=get(categorical), y=get(numerical), weight=PWGTP)) +\n    geom_boxplot()\n}"
  },
  {
    "objectID": "index.html#establishing-the-query-function",
    "href": "index.html#establishing-the-query-function",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "We need to construction a function to query the API [use the GET() function from library(httr)]. A helper function will be needed to take what is returned by get to turn it into a “nice tibble”.\nThis will be a function to query the API that allows the user to specify:\n\nYear of survey (default is 2022; must be a valid value between 2010 and 2022).\nThe numeric variables that could be queried for are:\n\nPWGTP - PUMS person weight, indicating the number of people that a single “person” record could “speak” for. (This variable must be included, and can not be removed by the user.)\nAGEP - Person age (default value along with PWGTP, but this one can be changed)\nGASP - The cost of gas for housing during the 12-month period reviewed.\nGRPIP - Gross Rent as a Percentage of household Income\nJWDP (time) - Time of departure for work.\nJWAP (time) - Time of arrival at work.\nJWMNP - The number of minutes spent commuting to work.\n\nThe categorical variables that could be queried for are:\n\nSEX - This was intended to refer to biological sex of the survey responder, but this survey is self-reporting and voluntary. This is to be the default categorical variable, and multiple can be selected.\nFER - Refers to “fertility”, an indicator variable for whether a woman has given birth within the previous 12 months from the survey. This is only valid for women aged 15 to 50.\nHHL - The household language.\nHISPEED - Indicates if the residence has high-speed internet (fiber optic, DSL, etc.)\nJWTRNS - The primary means of transportation to go to work.\nSCH - School enrollment, this indicates whether a person is currently enrolled in school; and what level they may be in.\nSCHL - The level of degree/schooling a person has received.\n\nThe geographic levels (All, Region, Division, State) should be specified.\nAny numeric, categorical, or geographic levels not specified above will be disregarded."
  },
  {
    "objectID": "index.html#generation-of-the-api-access-function",
    "href": "index.html#generation-of-the-api-access-function",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "The first step for generation of the function will be to ensure the packages to include, and our constants, are clearly defined. In this case, the constants are the allowable numeric and categorical variables as specified above.\n\nALLOWED_NUMERIC &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\")  # PWGTP always added\nALLOWED_CATEG   &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\nGEO_FIELD       &lt;- c(\"All\"=NA, \"Region\"=\"REGION\", \"Division\"=\"DIVISION\", \"State\"=\"ST\")\nALLOWED_YEARS   &lt;- 2010:2022\n\n\n\n\nSpecific packages will need to be included, to allow us to utilize HTTP protocols to access the API. The data would be transferred as JSON packets, which will need to be translated into a readable format. Finally, the resulting data frames will need to be able to be manipulated and processed for further accessibility.\n\nlibrary(httr)       # For accessing the API with HTTP requests\nlibrary(jsonlite)   # For interpreting data received from API into a readable format.\nlibrary(tidyverse)  # For processing and manipulation of the data.\n\n\n\n\nThe user will be able to define some of the details of the request. These are: year, numeric variables, categorical variables, geographic area, and some filtering variables that would allow further sub-setting. Prior to any request being submitted to the API, the requested input needs to be validated to confirm it fits within required parameters. A helper function check_inputs will review the inputted parameters and stop activity if any items are out of scope.\n\n# Confirm that input request is within allowable parameters\ncheck_inputs &lt;- function(year, numeric_vars, cat_vars, geo, subset) {\n  # Year must be a single integer in our allowed range\n  if (!is.numeric(year) || length(year) != 1 || !(year %in% ALLOWED_YEARS)) {\n    stop(\"Year must be an integer in 2010–2022.\")\n  }\n  # At least one numeric variable (besides the weight PWGTP, which we auto-include)\n  if (length(numeric_vars) &lt; 1) stop(\"provide at least one numeric variable.\")\n  # Only allow variables listed in the spec\n  bad_num &lt;- setdiff(numeric_vars, ALLOWED_NUMERIC)\n  if (length(bad_num)) stop(\"unknown numeric variable(s): \", paste(bad_num, collapse = \", \"))\n  if (length(cat_vars) &lt; 1) stop(\"provide at least one categorical variable.\")\n  bad_cat &lt;- setdiff(cat_vars, ALLOWED_CATEG)\n  if (length(bad_cat)) stop(\"unknown categorical variable(s): \", paste(bad_cat, collapse = \", \"))\n  # Geography must be one of these levels\n  if (!(geo %in% names(GEO_FIELD))) {\n    stop(\"geo must be one of: \", paste(names(GEO_FIELD), collapse = \", \"))\n  }\n  # If a subset is given, it must match the chosen geography and be coded as API codes\n  if (!is.null(subset)) {\n    if (geo == \"All\") stop(\"subset cannot be used when geo = 'All'.\")\n    if (!is.character(subset) || any(!nzchar(subset))) {\n      stop(\"subset must be a character vector of codes for the chosen geography.\")\n    }\n  }\n  invisible(TRUE)\n}\n\n\n\n\nAs stated, the specifics for a query submitted to the API are done through so through the contents of the URL. The next functions generate the URL according to the search terms provided.\n\n# Form the base of the URL according to the year of the database to be used (defaults to 2022)\npums_base &lt;- function(year=2022) sprintf(\"https://api.census.gov/data/%d/acs/acs1/pums\", year)\n\n# Building the Census API URL\nbuild_url &lt;- function(year, get_vars, geo, subset_codes) {\n  base &lt;- pums_base(year)\n  geo_field &lt;- GEO_FIELD[[geo]]\n  \n  # Always include PWGTP (weight). Include geo field so it appears in results.\n  get_list &lt;- unique(c(get_vars, \"PWGTP\", if (!is.na(geo_field)) geo_field))\n  \n  # Encode only the list of columns after get=\n  url &lt;- paste0(base, \"?get=\", URLencode(paste(get_list, collapse = \",\")))\n  \n  # If user asked for a subset (e.g., specific states), add \"&ST=37,45\"\n  if (!is.na(geo_field) && length(subset_codes)) {\n    url &lt;- paste0(url, \"&\", geo_field, \"=\", paste(subset_codes, collapse = \",\"))\n  }\n  url\n}\n\n\n\n\nAssuming the variable inputs are appropriately within scope, the request would submitted to the API. The metadata that is returned would be coded (even after translating from JSON). Some helper functions are needed to translate these labels into human-readable variable names.\n\n# Get the variable dictionary (metadata) for a given year.\n# Returns a big list, or NULL if the request fails.\nget_variables_metadata &lt;- function(year) {\n  # Build the variables.json URL for the chosen year\n  url  &lt;- paste0(pums_base(year), \"/variables.json\")\n  # Make a GET request\n  resp &lt;- httr::GET(url)\n  # If HTTP error (e.g., 404/500), just return NULL quietly\n  if (httr::http_error(resp)) return(NULL)\n  # Pull the response text and convert from JSON to an R list\n  txt &lt;- httr::content(resp, as = \"text\", encoding = \"UTF-8\")\n  meta &lt;- jsonlite::fromJSON(txt, simplifyVector = FALSE)\n  return(meta)\n}\n\n# From the metadata list, build a simple lookup (named character vector)\n# for a variable: names = codes, values = human-readable labels.\n# If the variable has no labels, return NULL.\n# label_lookup(): always return named {code -&gt; label} \nlabel_lookup &lt;- function(meta, var) {\n  if (is.null(meta) || is.null(meta$variables)) return(NULL)\n  entry &lt;- meta$variables[[var]]\n  if (is.null(entry) || is.null(entry$values)) return(NULL)\n  vals &lt;- entry$values\n  # 0) If it's already a nice data.frame with code/label columns\n  if (is.data.frame(vals)) {\n    code_col  &lt;- intersect(c(\"item\",\"value\",\"code\",\"id\"), names(vals))[1]\n    label_col &lt;- intersect(c(\"label\",\"text\",\"description\",\"name\"), names(vals))[1]\n    if (!is.na(code_col) && !is.na(label_col)) {\n      labs &lt;- as.character(vals[[label_col]])\n      names(labs) &lt;- as.character(vals[[code_col]])\n      return(labs)\n  } }\n  # 1) Try to normalize any odd list shape into a data.frame\n  #    by round-tripping through JSON with simplifyVector = TRUE\n  norm &lt;- try(\n    jsonlite::fromJSON(jsonlite::toJSON(vals, auto_unbox = TRUE),\n                       simplifyVector = TRUE),\n    silent = TRUE)\n  if (!inherits(norm, \"try-error\")) {\n    # A) data.frame with columns\n    if (is.data.frame(norm)) {\n      code_col  &lt;- intersect(c(\"item\",\"value\",\"code\",\"id\"), names(norm))[1]\n      label_col &lt;- intersect(c(\"label\",\"text\",\"description\",\"name\"), names(norm))[1]\n      if (!is.na(code_col) && !is.na(label_col)) {\n        labs &lt;- as.character(norm[[label_col]])\n        names(labs) &lt;- as.character(norm[[code_col]])\n        return(labs)\n      } }\n    # B) list with vectors item/label\n    if (is.list(norm) && !is.null(norm$item) && !is.null(norm$label)) {\n      labs &lt;- as.character(norm$label)\n      names(labs) &lt;- as.character(norm$item)\n      return(labs)\n    } }\n  # 2) As a last resort, handle named list/vector directly\n  if (is.list(vals) && !is.null(vals$item) && !is.null(vals$label)) {\n    labs &lt;- as.character(vals$label)\n    names(labs) &lt;- as.character(vals$item)\n    return(labs)\n  }\n  if (!is.null(names(vals))) {\n    labs &lt;- vapply(vals, function(x) {\n      if (is.list(x)) as.character(x[[1]])[1] else as.character(x)[1]\n    }, character(1))\n    names(labs) &lt;- names(vals)\n    return(labs)\n  }\n  # If there is no reliable mapping, then return null.\n  NULL\n}\n\n# Default labels we can fall back to if metadata is awkward\ndefault_labels &lt;- function(var) {\n  if (var == \"SEX\")  return(c(`1`=\"Male\", `2`=\"Female\"))\n  if (var == \"SCHL\") return(c(`16`=\"Regular high school diploma\",\n                              `21`=\"Bachelor's degree\"))\n  NULL\n}\n\n# Is the label map usable for these codes? (must have names, and at least one match)\nvalid_labs &lt;- function(codes_chr, labs_named) {\n  if (is.null(labs_named) || is.null(names(labs_named))) return(FALSE)\n  nm2    &lt;- sub(\"^0+\", \"\", names(labs_named))\n  codes2 &lt;- sub(\"^0+\", \"\", codes_chr)\n  any(codes2 %in% nm2)\n}\n\n# turn raw strings into useful R columns---------------------------------\ncoerce_columns &lt;- function(df, year, numeric_vars, cat_vars, geo) {\n  meta &lt;- get_variables_metadata(year)\n  # 1) plain numeric variables (JWAP/JWDP handled below)\n  plain_numeric &lt;- setdiff(numeric_vars, c(\"JWAP\",\"JWDP\"))\n  for (v in plain_numeric) {\n    if (v %in% names(df)) df[[v]] &lt;- suppressWarnings(as.numeric(df[[v]]))\n  }\n  # 2) time variables -&gt; numeric midpoints (prefer labels; fallback numeric)\n  for (tv in intersect(c(\"JWAP\",\"JWDP\"), numeric_vars)) {\n    if (tv %in% names(df)) {\n      labs_raw &lt;- label_lookup(meta, tv)\n      labs     &lt;- if (valid_labs(df[[tv]], labs_raw)) labs_raw else default_labels(tv)\n      \n      lbl &lt;- map_labels(as.character(df[[tv]]), labs)\n      if (all(is.na(lbl))) {\n        df[[tv]] &lt;- suppressWarnings(as.numeric(df[[tv]]))  # fallback if still no match\n      } else {\n        df[[tv]] &lt;- vapply(lbl, midpoint_from_label, numeric(1))\n      } } }\n  # 3) categorical variables -&gt; factors with readable labels\n  for (cv in cat_vars) {\n    if (cv %in% names(df)) {\n      labs_raw  &lt;- label_lookup(meta, cv)\n      labs      &lt;- if (valid_labs(df[[cv]], labs_raw)) labs_raw else default_labels(cv)\n      lbl       &lt;- map_labels(as.character(df[[cv]]), labs)\n      if (all(is.na(lbl))) {\n        df[[cv]] &lt;- factor(df[[cv]])              # keep codes if we truly can’t map\n      } else {\n        df[[cv]] &lt;- factor(lbl, levels = unique(unname(labs)))\n      } } }\n  # 4) weights numeric\n  if (\"PWGTP\" %in% names(df)) df$PWGTP &lt;- suppressWarnings(as.numeric(df$PWGTP))\n  # 5) label the geography field too (if present)\n  geo_field &lt;- GEO_FIELD[[geo]]\n  if (!is.na(geo_field) && geo_field %in% names(df)) {\n    labs_raw &lt;- label_lookup(meta, geo_field)\n    labs     &lt;- if (valid_labs(df[[geo_field]], labs_raw)) labs_raw else default_labels(geo_field)\n    if (!is.null(labs)) {\n      lbl &lt;- map_labels(as.character(df[[geo_field]]), labs)\n      if (all(is.na(lbl))) {\n        df[[geo_field]] &lt;- factor(df[[geo_field]])\n      } else {\n        df[[geo_field]] &lt;- factor(lbl, levels = unique(unname(labs)))\n      }\n    } else {\n      df[[geo_field]] &lt;- factor(df[[geo_field]])\n    } }\n  df\n}\n\nThe above helper functions are each set up to submit URL requests, receive the data, and process them into readable formats. The following functions pums_get_one_year and pums_get_multi_year process and submit the requests based on whether the query is for one year of data, or for multiple years.\n\n# pulling one year of PUMS--------------------------------- \npums_get_one_year &lt;- function(year, numeric_vars, cat_vars, geo, subset = NULL) {\n  # 1) validate inputs\n  check_inputs(year, numeric_vars, cat_vars, geo, subset)\n  # 2) build URL (PWGTP auto-added in build_url)\n  get_vars &lt;- unique(c(numeric_vars, cat_vars))\n  subset_codes &lt;- if (is.null(subset)) character(0) else subset\n  url &lt;- build_url(year, get_vars, geo, subset_codes)\n  # 3) call the API\n  resp &lt;- httr::GET(url)\n  if (httr::http_error(resp)) {\n    stop(\"API request failed. Status: \", httr::status_code(resp))\n  }\n  # 4) parse JSON (first row = header)\n  txt &lt;- httr::content(resp, as = \"text\", encoding = \"UTF-8\")\n  arr &lt;- jsonlite::fromJSON(txt, simplifyVector = TRUE)\n  if (NROW(arr) &lt; 2) stop(\"API returned no data for these parameters.\")\n  header &lt;- arr[1, ]\n  dat &lt;- tibble::as_tibble(as.data.frame(arr[-1, , drop = FALSE],\n                                         stringsAsFactors = FALSE))\n  names(dat) &lt;- header\n  # 5) coerce + label\n  dat &lt;- coerce_columns(dat, year, numeric_vars, cat_vars, geo)\n  # 6) tag and return\n  as_census(dat)\n}\n\n\n# pulling multiple years (loop + bind rows)------------------------\npums_get_multi_year &lt;- function(years, numeric_vars, cat_vars, geo, subset ) {\n  if (!is.numeric(years) || any(!(years %in% ALLOWED_YEARS))) {\n    stop(\"all years must be in 2010–2022.\")\n  }\n  parts &lt;- vector(\"list\", length(years))\n  for (i in seq_along(years)) {\n    y &lt;- years[i]\n    one &lt;- pums_get_one_year(y, numeric_vars, cat_vars, geo, subset)\n    one$year &lt;- y\n    parts[[i]] &lt;- one\n  }\n  out &lt;- dplyr::bind_rows(parts)\n  as_census(out)\n}"
  },
  {
    "objectID": "index.html#final-user-function",
    "href": "index.html#final-user-function",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "A single function can be utilized then that will take the user’s request, and submit it to either of the above functions based on whether the years variable contains a single year or multiple years.\n\n# FUNCTION: pums(years, numeric_vars, cat_vars, geo, subset)\n# Usage: Each variable is a keyword where either a vector (for numeric_vars\n# or cat_vars) or singular variable should be used. \n\n# Default variables:\n# year = 2022\n# numeric_vars: c(\"AGEP\")\n# character_vars: c(\"SEX\")\n# geo: \"All\"\n# subset: null\n\npums &lt;- function(year = 2022,\n                 numeric_vars = c(\"AGEP\"),\n                 cat_vars = c(\"SEX\"),\n                 geo = \"All\",\n                 subset = null) {\n  # Confirm whether `year` is a single numeric value\n  if (length(year) == 1 & is.numeric(year)) {\n    pums_get_one_year(year, numeric_vars, cat_vars, geo, subset)\n  } else if (length(year) &gt; 1 & is.numeric(year)) {\n    pums_get_multi_year(year, numeric_vars, cat_vars, geo, subset)\n  } else stop(\"Unable to process `year` request. Please enter either a single integer for year or a vector of years.\")\n}"
  },
  {
    "objectID": "index.html#writing-generic-function-for-summarizing",
    "href": "index.html#writing-generic-function-for-summarizing",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "A summary function has been created to take our census objects and provide some statistical information.\nThe function was created in a way that took up to three variables:\n\nThe census item generated in the function above;\n(OPTIONAL) A vector or single item with keyword numerics= which will contain the numeric variables selected. An error is generated if the keyword numerics= is used with a categorical column.\n\n\nNote: The PWGTP variable is not returned by default. This must be specifically requested in numerics= in order to call it.\n\n\n(OPTIONAL) A vector or single item with the keyword categoricals= which will contain the categorical variables selected. An error is generated in the keyword categoricals= is used with a numeric column.\n\nThe summary statistics returned will be the mean and standard deviation for each numeric variable, and the counts of each factor for categorical variables. These are returned as named lists, which are convenient for assigning to a variable and calling specific items.\n\nsummary.census &lt;- function(object, ...) {\n  \n  args &lt;- list(...)\n  \n  # Stop if any keywords are included that are not `numerics` or `categoricals`\n  if (length(setdiff(names(args), c(\"numerics\", \"categoricals\")))) {\n    stop(\"Keyword error: keywords must be `numerics=` or `categoricals=` to specify column summary request.\")\n  }\n  \n  # If `numerics` are provided, confirm they are actually numeric variables:\n  if (\"numerics\" %in% names(args)) {\n    if (!all(sapply(object[args$numerics], is.numeric))) {\n      stop(\"Selected numeric variables should all be numeric.\")\n    } else { numerics &lt;- args$numerics }\n  } else {\n    numerics &lt;- names(select(object, where(is.numeric)))\n    # Unless it's specified, do not return PWGTP variable.    \n    numerics &lt;- numerics[!numerics %in% \"PWGTP\"]\n  }\n  \n  # If `categoricals` are provided, confirm they're actually factors:\n  if (\"categoricals\" %in% names(args)) {\n    if (!all(sapply(object[args$categoricals], is.factor))) {\n      stop(\"Selected categorical variables should all be factors.\")\n    } else { categoricals &lt;- args$categoricals }\n  } else categoricals &lt;- names(select(object, where(is.factor)))\n  \n  # Reduce the input `object` to its selected variables.\n  object &lt;- object |&gt; select(numerics, categoricals)\n  \n  # Function to produce `summary` reporting for census object\n  report &lt;- function(obj) {\n    # Numeric variables: return a named list with `mean` and `sigma`\n    if (class(obj) == \"numeric\") list(mean=mean(obj), sigma=sd(obj))\n    # Categorical variables: return unique factors and their counts.\n    else if (class(obj) == \"factor\") table(obj)\n    # Fail if object class is neither numeric nor factor.\n    else stop(\"Improper class passed to report function.\")\n  }\n  lapply(as.list(object), FUN=report)\n}\n\n# THIS IS JUST TO SHOW THAT IT WORKS. Show some examples using the function created here.\nexample &lt;- iris\nclass(example) &lt;- c(\"census\", class(iris))\nsummary(example)\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(numerics)\n\n  # Now:\n  data %&gt;% select(all_of(numerics))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(categoricals)\n\n  # Now:\n  data %&gt;% select(all_of(categoricals))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\n$Sepal.Length\n$Sepal.Length$mean\n[1] 5.843333\n\n$Sepal.Length$sigma\n[1] 0.8280661\n\n\n$Sepal.Width\n$Sepal.Width$mean\n[1] 3.057333\n\n$Sepal.Width$sigma\n[1] 0.4358663\n\n\n$Petal.Length\n$Petal.Length$mean\n[1] 3.758\n\n$Petal.Length$sigma\n[1] 1.765298\n\n\n$Petal.Width\n$Petal.Width$mean\n[1] 1.199333\n\n$Petal.Width$sigma\n[1] 0.7622377\n\n\n$Species\nobj\n    setosa versicolor  virginica \n        50         50         50"
  },
  {
    "objectID": "index.html#plot-function",
    "href": "index.html#plot-function",
    "title": "ST 558 Project 1",
    "section": "",
    "text": "Similar to the summary adaptation above, a plot adaptation is also generated for census objects. This is designed to require a single categorical variable and a single numerical variable, as strings. The usage for this command is\nplot(object, categorical=\"[Categorical Var]\", numerical=\"[Numerical Variable]\")\nwhere [Categorical Var] and [Numerical Var] are substitued with the names of the desired columns of their requisite classes.\n\n# Run plot() on a `census` object.\n\nplot.census &lt;- function(object, categorical, numerical, ...) {\n  args = list(...) # Look at possibly adding options for customization. Add a title, for instance?\n  ggplot(object,\n         aes(x=get(categorical), y=get(numerical), weight=PWGTP)) +\n    geom_boxplot()\n}"
  }
]